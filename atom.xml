<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I am Oliver</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ochukai.me/"/>
  <updated>2016-12-30T03:55:16.592Z</updated>
  <id>http://blog.ochukai.me/</id>
  
  <author>
    <name>Oliver Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 绑定 this</title>
    <link href="http://blog.ochukai.me/js-bind-this/"/>
    <id>http://blog.ochukai.me/js-bind-this/</id>
    <published>2016-12-30T02:28:20.000Z</published>
    <updated>2016-12-30T03:55:16.592Z</updated>
    
    <content type="html"><![CDATA[<p>其实这篇文章主要是介绍这个东西 <a href="https://github.com/tc39/proposal-bind-operator" target="_blank" rel="external">Proposal Bind Operator</a> 或者 <a href="http://wiki.ecmascript.org/doku.php?id=strawman:bind_operator" target="_blank" rel="external">bind_operator</a>。</p>
<p>也是在一个很偶然的机会看到了，git 上面的一个项目用到了这个用法，为什么自己发现不了这些东西呢？</p>
<h2 id="传统的-this-绑定"><a href="#传统的-this-绑定" class="headerlink" title="传统的 this 绑定"></a>传统的 this 绑定</h2><h3 id="在函数外面暂存一个变量"><a href="#在函数外面暂存一个变量" class="headerlink" title="在函数外面暂存一个变量"></a>在函数外面暂存一个变量</h3><pre><code class="js">// 别名
var self = this;
setTimeout(function() {
  this.doSomething();
}, 1000);
</code></pre>
<h3 id="使用-bind-函数-amp-箭头函数"><a href="#使用-bind-函数-amp-箭头函数" class="headerlink" title="使用 bind 函数 &amp; 箭头函数"></a>使用 bind 函数 &amp; 箭头函数</h3><p>在使用 <code>class *** extends React.Component {}</code> 的写法声明 React 组件的时候，组件的方法都不会被自动绑定 this 了，下面的两种方法比较常见：</p>
<pre><code class="js">// bind
setTimeout(
  function() {
    this.doSomething();
  }.bind(this), 
  1000
);
</code></pre>
<p>使用 <code>bind</code> 方法显得稍微有点长，不太好看，不过很好用。</p>
<pre><code class="js">// var _this = this;

// bind
setTimeout(
  () =&gt; {
    // _this.doSomething();
    this.doSomething();
  }, 
  1000
);
</code></pre>
<p>箭头函数在经过<code>babel</code>编译后， 差不多就是注释的部分了， 还是用的暂存的办法保存了 <code>this</code>，但是写法就简单了太多。</p>
<h3 id=""><a href="#" class="headerlink" title="::"></a>::</h3><p>看到这种语法之后，感觉其他的都弱爆了。</p>
<p>在 React 里面，可以这么写</p>
<pre><code class="jsx">// { title: &#39;******************&#39;, onConfirm: this.handleSave.bind(this) },
&lt;Popconfirm title=&quot;确定要保存吗？&quot; onConfirm={::this.handleSave}&gt;
  &lt;Button type=&quot;ghost&quot; &gt;保存&lt;/Button&gt;
&lt;/Popconfirm&gt;
</code></pre>
<p>可以看到，注释部分表示的编译后的代码，就是用 <code>bind</code> 实现的。</p>
<p>双冒号前面的对象就是 <code>bind</code> 的参数， 如果没有就是当前的 <code>this</code>, 毕竟这种做法就是用来做绑定的。</p>
<p>但是有一个问题，就是像这样的需求不好实现，</p>
<pre><code class="jsx">&lt;Button
  type=&quot;ghost&quot;
  icon=&quot;edit&quot;
  onClick={this.handleEdit.bind(this, item)}
/&gt;
</code></pre>
<p>然后就是黑人问号脸，我试了几种形式 (当然不能用 bind 方法，否则这 :: 没有意义了)</p>
<ul>
<li>[this, item]::this.handleEdit</li>
<li>(this, item)::this.handleEdit  // hhh</li>
<li>this::this.handleEdit(item)    // hhh</li>
</ul>
<p>感觉唯一靠谱的就是第一种写法了， 编译之后</p>
<pre><code class="js">_react2.default.createElement(
  _button2.default,
  { 
    type: &#39;ghost&#39;, 
    icon: &#39;edit&#39;, 
    onClick: (_context = [this, item], this.handleEdit).bind(_context) 
  },
  &#39;&#39;
)
</code></pre>
<p>这样 bind 之后的方法内的 this 是一个数组，要想获取到真正的 this, 在 handleEdit 中还需要做</p>
<pre><code class="js">function handleEdit () {
  // this: [this, item]
  // 感觉好尴尬~
  console.log(this[0]);
  // const [ _this, item ] = this;
}
</code></pre>
<blockquote>
<p>所以呢 在需要绑定 this 并且要添加额外参数的时候，就不要用 <strong>::</strong> 了。老老实实用 <strong>bind</strong> 就好了。</p>
</blockquote>
<h2 id="箭头函数声明在-class-里面"><a href="#箭头函数声明在-class-里面" class="headerlink" title="箭头函数声明在 class 里面"></a>箭头函数声明在 class 里面</h2><pre><code class="jsx">class Example extends React.Component {

  handleButtonClick = (e) =&gt; {
    this.setState({ loading: true });
  };

  render() {
    return &lt;Button onClick={this.handleButtonClick}&gt;;
  }

}

// var Example = React.createClass({
//
//   handleButtonClick: function(e) {
//     this.setState({ loading: true });
//   },
//   ...
// });
</code></pre>
<p>这样应该是最简单的方式了，因为是自动绑定 this 的（与注释中的代码效果是一样的）。</p>
<p>以上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这篇文章主要是介绍这个东西 &lt;a href=&quot;https://github.com/tc39/proposal-bind-operator&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Proposal Bind Operator&lt;/a&gt; 或者 &lt;a 
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.ochukai.me/categories/javascript/"/>
    
    
      <category term="this" scheme="http://blog.ochukai.me/tags/this/"/>
    
      <category term="js" scheme="http://blog.ochukai.me/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>修改 WebStorm 里面丑陋的 Markdown 样式</title>
    <link href="http://blog.ochukai.me/correct-ugly-markdown-css-in-webstorm/"/>
    <id>http://blog.ochukai.me/correct-ugly-markdown-css-in-webstorm/</id>
    <published>2016-12-23T07:27:27.000Z</published>
    <updated>2016-12-23T07:37:41.376Z</updated>
    
    <content type="html"><![CDATA[<p>一直觉得在 webstrom 里面看 markdown 是一种折磨，尤其是有 table 的情况下，很不爽！！！</p>
<p>今天突然发现有一个设置项可以自定义 markdown 的样式，</p>
<p><img src="../images/webstorm-md-css-1.png" alt="设置"></p>
<p>就是右边方框里面的选项，取消 webstorm 默认的， 然后添加自己的 css，下面的css 是我找来的，还可以看：</p>
<pre><code class="css">body{
    background-color: #fff;
    margin: 0 auto;
    font-family: Georgia, Palatino, serif;
    color: #333333;
    line-height: 120%;
    max-width: 960px;
    padding: 30px;
    font-size: 12px;
}
h1, h2, h3, h4 {
    color: #111111;
    font-weight: 400;
}
h1, h2, h3, h4, h5, p {
    margin-bottom: 18px;
    padding: 0;
}
h1 {
    font-size: 36px;
}
h2 {
    font-size: 24px;
    margin: 18px 0 6px;
}
h3 {
    font-size: 20px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 12px;
}
a {
    color: #0099ff;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
}
a:hover {
    text-decoration: none;
    color: #ff6600;
}
a:visited {
    color: purple;
}
ul, ol {
    padding: 0;
    margin-left: 18px;
    margin-bottom: 18px;
}
li {
    line-height: 18px;
}
li ul, li ul {
    margin-left: 18px;
}
p, ul, ol {
    font-size: 12px;
    line-height: 1.5;
    max-width: 540px;
}

blockquote {
   padding: 12px 12px 12px 15px;
   margin-bottom: 16px;
   font-family:georgia,serif;
   font-style: italic;
   border-left: 2px solid #d9d9d9;
}
blockquote p {
   font-size: 12px;
   font-weight: 300;
   line-height: 1.2;
   margin-bottom: 0;
   font-style: italic;
}
code, pre {
   font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
   background-color: #fee9cc;
   color: #000000;
   padding: 1px 3px;
   font-size: 12px;
   border-radius: 3px;
}
pre {
   display: block;
   padding: 14px;
   margin: 0 0 18px;
   line-height: 16px;
   font-size: 11px;
   border: 1px solid #d9d9d9;
   white-space: pre-wrap;
   word-wrap: break-word;
}
pre code {
   background-color: #ffffff;
   color:#666666;
   font-size: 11px;
   padding: 0;
}

aside {
    display: block;
    float: right;
    width: 390px;
}


hr {
    width: 540px;
    text-align: left;
    margin: 0 auto 0 0;
    color: #999999;
}

/* Code below this line is copyright Twitter Inc. */

button,
input,
select,
textarea {
  font-size: 100%;
  margin: 0;
  vertical-align: baseline;
  *vertical-align: middle;
}
button, input {
  line-height: normal;
  *overflow: visible;
}
button::-moz-focus-inner, input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
button,
input[type=&quot;button&quot;],
input[type=&quot;reset&quot;],
input[type=&quot;submit&quot;] {
  cursor: pointer;
  -webkit-appearance: button;
}
input[type=checkbox], input[type=radio] {
  cursor: pointer;
}
/* override default chrome &amp; firefox settings */
input:not([type=&quot;image&quot;]), textarea {
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

input[type=&quot;search&quot;] {
  -webkit-appearance: textfield;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}
input[type=&quot;search&quot;]::-webkit-search-decoration {
  -webkit-appearance: none;
}
label,
input,
select,
textarea {
  font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;
  font-size: 13px;
  font-weight: normal;
  line-height: normal;
  margin-bottom: 18px;
}
input[type=checkbox], input[type=radio] {
  cursor: pointer;
  margin-bottom: 0;
}
input[type=text],
input[type=password],
textarea,
select {
  display: inline-block;
  width: 210px;
  padding: 4px;
  font-size: 13px;
  font-weight: normal;
  line-height: 18px;
  height: 18px;
  color: #808080;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}
select, input[type=file] {
  height: 27px;
  line-height: 27px;
}
textarea {
  height: auto;
}

/* grey out placeholders */
:-moz-placeholder {
  color: #bfbfbf;
}
::-webkit-input-placeholder {
  color: #bfbfbf;
}

input[type=text],
input[type=password],
select,
textarea {
  -webkit-transition: border linear 0.2s, box-shadow linear 0.2s;
  -moz-transition: border linear 0.2s, box-shadow linear 0.2s;
  transition: border linear 0.2s, box-shadow linear 0.2s;
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}
input[type=text]:focus, input[type=password]:focus, textarea:focus {
  outline: none;
  border-color: rgba(82, 168, 236, 0.8);
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
}

/* buttons */
button {
  display: inline-block;
  padding: 4px 14px;
  font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;
  font-size: 13px;
  line-height: 18px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  background-color: #0064cd;
  background-repeat: repeat-x;
  background-image: -khtml-gradient(linear, left top, left bottom, from(#049cdb), to(#0064cd));
  background-image: -moz-linear-gradient(top, #049cdb, #0064cd);
  background-image: -ms-linear-gradient(top, #049cdb, #0064cd);
  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #049cdb), color-stop(100%, #0064cd));
  background-image: -webkit-linear-gradient(top, #049cdb, #0064cd);
  background-image: -o-linear-gradient(top, #049cdb, #0064cd);
  background-image: linear-gradient(top, #049cdb, #0064cd);
  color: #fff;
  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
  border: 1px solid #004b9a;
  border-bottom-color: #003f81;
  -webkit-transition: 0.1s linear all;
  -moz-transition: 0.1s linear all;
  transition: 0.1s linear all;
  border-color: #0064cd #0064cd #003f81;
  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
}
button:hover {
  color: #fff;
  background-position: 0 -15px;
  text-decoration: none;
}
button:active {
  -webkit-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
  -moz-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
}
button::-moz-focus-inner {
  padding: 0;
  border: 0;
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直觉得在 webstrom 里面看 markdown 是一种折磨，尤其是有 table 的情况下，很不爽！！！&lt;/p&gt;
&lt;p&gt;今天突然发现有一个设置项可以自定义 markdown 的样式，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/webstorm-md-cs
    
    </summary>
    
      <category term="WebStorm" scheme="http://blog.ochukai.me/categories/webstorm/"/>
    
    
      <category term="markdown" scheme="http://blog.ochukai.me/tags/markdown/"/>
    
      <category term="webstrom" scheme="http://blog.ochukai.me/tags/webstrom/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 Decorator</title>
    <link href="http://blog.ochukai.me/decorator-in-js/"/>
    <id>http://blog.ochukai.me/decorator-in-js/</id>
    <published>2016-12-21T01:33:38.000Z</published>
    <updated>2016-12-21T02:36:53.476Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在看一个拖拽库的时候，遇到了这么一段代码，感觉很有意思：</p>
<pre><code class="jsx">@sortable
class DemoHOCItem extends React.Component {

  render() {
    return (
      &lt;div { ...this.props }&gt;
        { this.props.children }
      &lt;/div&gt;
    );
  }

}
</code></pre>
<p>查了一下之后发现这是 es7 的新语法，叫 <a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="external">Decorator</a>。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>如果要定义一个 Decorator 的话，不难，其实每一个 decorator 就是一个 function，有三个参数，像这样</p>
<pre><code class="js">let log = (target, name, descriptor) =&gt; {
  console.log(target, name, descriptor);

  const method = descriptor.value;
  descriptor.value = (...args) =&gt; {
    logger.info(`before function execute: ${name}(${args}) = ?`);
    return method.apply(target, args);
  }
}
</code></pre>
<p>三个参数还是比较好理解的</p>
<p>然后要用这个 decorator 的时候</p>
<pre><code class="js">class Example {

  @log
  add(a, b) {
    return a + b;
  }

}

let my = new Example();
my.add(2, 3);
</code></pre>
<p>这好像跟 Java 的 Annotation 形式差不多。 但是功能却跟 Python 的 Decorator 一样。</p>
<p>下面是运行时的输出</p>
<p><img src="..//images/decorator-1.png" alt="正常"></p>
<p>所以呢，decorator 的三个参数分别是</p>
<ol>
<li>target 目标方法所在的类</li>
<li>name 方法名</li>
<li>descriptor 该方法的一些描述， 其中 <code>value</code> 就是方法本身，这一点再上一个例子中已经用过了。</li>
</ol>
<h2 id="用在-class-上面"><a href="#用在-class-上面" class="headerlink" title="用在 class 上面"></a>用在 class 上面</h2><p>因为我最开始见到 decorator 是看到</p>
<pre><code class="jsx">@sortable
class DemoHOCItem extends React.Component {/*...*/}
</code></pre>
<p>这时， decorator 是用在 class 上面的，当 decorator 用在 class 上面的时候只有第一个参数有值，比如</p>
<pre><code class="js">@log
class Example {

  @log
  add(a, b) { return a + b; }

}
</code></pre>
<p>只会输出</p>
<pre><code class="shell"># 也就是 name, descriptor 都是 undefined
2016-12-21 10:28:26.617 function Example() {
        _classCallCheck(this, Example);
    } undefined undefined
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天在看一个拖拽库的时候，遇到了这么一段代码，感觉很有意思：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;@sortable
class DemoHOCItem extends React.Component {

  render() {
    return 
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.ochukai.me/categories/javascript/"/>
    
    
      <category term="decorator" scheme="http://blog.ochukai.me/tags/decorator/"/>
    
  </entry>
  
  <entry>
    <title>使用命令行更新 Win10 的密钥</title>
    <link href="http://blog.ochukai.me/use-terminal-to-update-win10-key/"/>
    <id>http://blog.ochukai.me/use-terminal-to-update-win10-key/</id>
    <published>2016-12-16T05:02:13.000Z</published>
    <updated>2016-12-16T06:58:09.484Z</updated>
    
    <content type="html"><![CDATA[<p>今天在公司装了 win10，但是点击更换密钥的时候老是卡死，然后就搜了一下发现可以用命令行设置</p>
<pre><code class="shell"># 设置密钥
slmgr /ipk DDCGG-9N3QJ-2B23T-C***V-XD72F

# 检查是否已激活
slmgr.vbs -ato
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在公司装了 win10，但是点击更换密钥的时候老是卡死，然后就搜了一下发现可以用命令行设置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 设置密钥
slmgr /ipk DDCGG-9N3QJ-2B23T-C***V-XD72F

# 检查是否已激活
s
    
    </summary>
    
      <category term="Window" scheme="http://blog.ochukai.me/categories/window/"/>
    
    
      <category term="win10" scheme="http://blog.ochukai.me/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>webpack-dev-server 在 webstorm 中失效的问题</title>
    <link href="http://blog.ochukai.me/webpack-dev-server-vs-webstorm/"/>
    <id>http://blog.ochukai.me/webpack-dev-server-vs-webstorm/</id>
    <published>2016-12-08T11:32:09.000Z</published>
    <updated>2016-12-08T11:52:29.532Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了公司 ！！！</p>
<p>重新用上了高大上的 win7 系统，还是熟悉的画面，然后又装上了 WebStorm，准备开始我的性福人生。</p>
<p>但天有不测风云，在使用一个基于 webpack 构建的项目中，每次修改代码之后，webpack-dev-server 总是不能够自动重新编译，很烦！！！</p>
<p>这可急坏了宝宝！！！</p>
<p>但是我非常冷静的分析了一下原因，可能是因为webstorm有自动保存的机制， 是不是很机智，一下子就命中了要害（但其实这中间的过程可复杂了）</p>
<p><img src="..//images/webstorm-save-file.png" alt="正常"></p>
<p>如上图， 在 <code>File -&gt; Settings -&gt; Appearance &amp; Behavior -&gt; System Settings</code> 里面，取消勾选上面红框的两项。</p>
<p>每次修改之后，<code>ctrl + s</code> 就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近换了公司 ！！！&lt;/p&gt;
&lt;p&gt;重新用上了高大上的 win7 系统，还是熟悉的画面，然后又装上了 WebStorm，准备开始我的性福人生。&lt;/p&gt;
&lt;p&gt;但天有不测风云，在使用一个基于 webpack 构建的项目中，每次修改代码之后，webpack-dev-server
    
    </summary>
    
      <category term="WebStorm" scheme="http://blog.ochukai.me/categories/webstorm/"/>
    
    
      <category term="webpack-dev-server" scheme="http://blog.ochukai.me/tags/webpack-dev-server/"/>
    
      <category term="webpack" scheme="http://blog.ochukai.me/tags/webpack/"/>
    
      <category term="webstorm" scheme="http://blog.ochukai.me/tags/webstorm/"/>
    
  </entry>
  
  <entry>
    <title>在 window 里面杀死某个进程</title>
    <link href="http://blog.ochukai.me/kill-process-in-window/"/>
    <id>http://blog.ochukai.me/kill-process-in-window/</id>
    <published>2016-11-22T01:49:57.000Z</published>
    <updated>2016-12-08T11:50:20.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看被谁占用"><a href="#查看被谁占用" class="headerlink" title="查看被谁占用"></a>查看被谁占用</h2><pre><code class="shell">netstat -ano | findstr 8989

# C:\Users\Administrator&gt;netstat -ano | findstr 8989
#   TCP    0.0.0.0:8989           0.0.0.0:0              LISTENING       6360
#   TCP    [::]:8989              [::]:0                 LISTENING       6360
#   TCP    [::1]:8989             [::1]:53638            ESTABLISHED     6360
#   TCP    [::1]:8989             [::1]:53640            ESTABLISHED     6360
#   TCP    [::1]:8989             [::1]:53641            ESTABLISHED     6360
#   TCP    [::1]:8989             [::1]:53645            ESTABLISHED     6360
#   TCP    [::1]:8989             [::1]:53646            ESTABLISHED     6360
#   TCP    [::1]:8989             [::1]:53652            ESTABLISHED     6360
#   TCP    [::1]:8989             [::1]:53653            ESTABLISHED     6360
#   TCP    [::1]:8989             [::1]:53654            ESTABLISHED     6360
#   TCP    [::1]:53638            [::1]:8989             ESTABLISHED     5440
#   TCP    [::1]:53640            [::1]:8989             ESTABLISHED     5440
#   TCP    [::1]:53641            [::1]:8989             ESTABLISHED     5440
#   TCP    [::1]:53645            [::1]:8989             ESTABLISHED     5440
#   TCP    [::1]:53646            [::1]:8989             ESTABLISHED     5440
#   TCP    [::1]:53652            [::1]:8989             ESTABLISHED     5440
#   TCP    [::1]:53653            [::1]:8989             ESTABLISHED     5440
#   TCP    [::1]:53654            [::1]:8989             ESTABLISHED     5440
</code></pre>
<pre><code class="shell">tasklist | findstr 8989//查看pid为3036的是什么程序在用
</code></pre>
<h2 id="杀死某进程"><a href="#杀死某进程" class="headerlink" title="杀死某进程"></a>杀死某进程</h2><pre><code class="shell"># /T 包括子进程
# /F 强制

taskkill /T /F /PID 8989
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查看被谁占用&quot;&gt;&lt;a href=&quot;#查看被谁占用&quot; class=&quot;headerlink&quot; title=&quot;查看被谁占用&quot;&gt;&lt;/a&gt;查看被谁占用&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;netstat -ano | findstr 8989

# C
    
    </summary>
    
      <category term="Window" scheme="http://blog.ochukai.me/categories/window/"/>
    
    
      <category term="端口占用" scheme="http://blog.ochukai.me/tags/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 中的 splice 方法</title>
    <link href="http://blog.ochukai.me/splice-in-javascript/"/>
    <id>http://blog.ochukai.me/splice-in-javascript/</id>
    <published>2016-11-22T01:40:09.766Z</published>
    <updated>2016-11-22T01:40:09.766Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。(会改变原始数组)</p>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code class="js">  arrayObject.splice(index, how-many, item1, item2, ...itemX)
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</td>
</tr>
<tr>
<td>how-many</td>
<td>必需。要删除的项目数量。<code>如果设置为 0，则不会删除项目</code>。</td>
</tr>
<tr>
<td>item1, …, itemX</td>
<td>可选。向数组添加的新项目。</td>
</tr>
</tbody>
</table>
<h2 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h2><p>在数组最开始插入一个元素</p>
<pre><code class="js">var arrr = [1,2,3,4];   // arrr: [1, 2, 3, 4]
arrr.splice(0, 0, 0);   // arrr: [0, 1, 2, 3, 4]
</code></pre>
<p>删除第三个</p>
<pre><code class="js">arrr.splice(3, 1) // return [3] 删除的元素会做为返回返回值
                  // arrr: [0, 1, 2, 4]
</code></pre>
<p>删除后面两个</p>
<pre><code class="js">arrr.splice(2, 2) // return [2， 4]
                  // arrr: [0, 1]
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。(会改变原始数组)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://blog.ochukai.me/categories/javascript/"/>
    
      <category term="[object Object]" scheme="http://blog.ochukai.me/categories/javascript/object-object/"/>
    
    
      <category term="js" scheme="http://blog.ochukai.me/tags/js/"/>
    
      <category term="splice" scheme="http://blog.ochukai.me/tags/splice/"/>
    
      <category term="array" scheme="http://blog.ochukai.me/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>东野圭吾(Higashino Keigo)的全集</title>
    <link href="http://blog.ochukai.me/higashino-keigo/"/>
    <id>http://blog.ochukai.me/higashino-keigo/</id>
    <published>2016-07-26T08:38:44.000Z</published>
    <updated>2016-11-22T01:40:09.751Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了几篇 东野圭吾 的小说, 都还蛮有意思的。 像 《嫌疑人X的献身》, 《流星之绊》,《毕业》啊 等等,好多都记不住名字了。</p>
<p>于是决定把他的全集整理一下,留着有空都看一遍~</p>
<hr>
<h2 id="加贺恭一郎系列"><a href="#加贺恭一郎系列" class="headerlink" title="加贺恭一郎系列"></a>加贺恭一郎系列</h2><ul>
<li>《毕业——雪月花杀人游戏》（《毕业前杀人游戏》）&lt;卒业―雪月花杀人ゲーム&gt;</li>
<li>《沉睡的森林》&lt;眠りの森&gt;</li>
<li>《谁杀了她》&lt;どちらかが彼女を杀した&gt;</li>
<li>《恶意》</li>
<li>《我杀了他》&lt;私が彼を杀した&gt;</li>
<li>《又一个谎言》 &lt;嘘をもうひとつだけ&gt;　刊载于推理杂志220-224期</li>
<li>《红手指》 &lt;赤い指&gt;（2011年冬季档日剧SP，阿部宽、黑木明纱主演）</li>
<li>《新参者》（2010年拍摄日剧，阿部宽、黑木明纱主演）</li>
<li>《麒麟之翼》&lt;麒麟の翼&gt;</li>
</ul>
<h2 id="神探伽利略-按列表顺序"><a href="#神探伽利略-按列表顺序" class="headerlink" title="神探伽利略 (按列表顺序)"></a>神探伽利略 (按列表顺序)</h2><ul>
<li>《侦探伽利略》&lt;探侦ガリレオ&gt;</li>
<li>《预知梦》&lt;予知梦&gt;</li>
<li>《嫌疑犯X的献身》&lt;容疑者Xの献身&gt;</li>
<li>《伽利略的苦恼》&lt;ガリレオの苦悩&gt;</li>
<li>《圣女的救济》&lt;圣女の救済&gt;</li>
<li>《盛夏的方程式》&lt;真夏の方程式&gt;</li>
<li>《虚像的小丑》&lt;虚像の道化师&gt;</li>
<li>《禁断的魔术》&lt;禁断の魔术&gt;</li>
</ul>
<h2 id="毒舌三部曲"><a href="#毒舌三部曲" class="headerlink" title="毒舌三部曲"></a>毒舌三部曲</h2><ul>
<li>怪笑小说</li>
<li>毒笑小说</li>
<li>黑笑小说</li>
</ul>
<h2 id="获奖作品"><a href="#获奖作品" class="headerlink" title="获奖作品"></a>获奖作品</h2><ul>
<li>1983年《人偶之家》第29届江戸川乱歩赏二次予选通过</li>
<li>1984年《魔球》第30届江戸川乱歩赏最终候补</li>
<li>1985年《放学后》夺得第31届江户川乱步奖，开始专职写作。</li>
<li>1988年《学生街杀人事件》第9届吉川英治文学新人赏候补・第41回日本推理作家协会赏（长编）候补</li>
<li>1990年《鸟人计划》第11届吉川英治文学新人赏候补</li>
<li>1991年《天使之耳》第44届日本推理作家协会赏（短编集）候补</li>
<li>1992年《镜之中》第45届日本推理作家协会赏（短编集）候补</li>
<li>1993年《雪地杀机》第46届日本推理作家协会赏（长编部）候补</li>
<li>1993年《交通警察之夜》第46届日本推理作家协会赏（短编集）候补</li>
<li>1996年《天空之蜂》第17届吉川英治文学新人赏候补</li>
<li>1997年《名侦探的守则》第18届吉川英治文学新人赏候补</li>
<li>1999年《秘密》第120届直木奖三十五赏候补，第20回吉川英治文学新人赏候补，第52回日本推理作家协会奖</li>
<li>2000年《白夜行》第122届直木奖三十五赏候补</li>
<li>2001年《单恋》第125届直木奖三十五赏候补</li>
<li>2003年《信》第129届直木奖三十五赏候补</li>
<li>2004年《幻夜》第131届直木三奖十五赏候补</li>
<li>2006年《嫌疑人X的献身》将第134届直木奖、第6届本格推理小说 大奖及当年度日本三大推理小说排行榜（“这本推理小说了不起！”、“周刊文春推理小说BEST10”、“本格推理小说 BEST10”）第1名一并收入囊中。</li>
<li>2008年《流星之绊》荣获第43届新风奖。</li>
<li>2009年《新参者》获“这本推理小说了不起！”、“周刊文春推理小说BEST10”年度第1名。</li>
<li>2012年《嫌疑犯X的献身》美国图书馆协会最推荐图书（推理部门）、爱伦·坡奖最优秀长编奖候补、巴瑞奖新人赏奖候补</li>
<li>2012年《浪矢杂货店的奇迹》第7届中央公论文艺奖</li>
</ul>
<hr>
<p>上面的作品今年都看完应该就不错了~ 毕竟做人都是要有目标的嘛,那么更远大的目标呢,就是下面的全部列表了。</p>
<hr>
<h2 id="作品列表"><a href="#作品列表" class="headerlink" title="作品列表"></a>作品列表</h2><h3 id="1985年"><a href="#1985年" class="headerlink" title="1985年"></a>1985年</h3><ol>
<li>《放学后》&lt;放课後&gt; （第31 届江户川乱步奖）</li>
</ol>
<h3 id="1986年"><a href="#1986年" class="headerlink" title="1986年"></a>1986年</h3><ol>
<li>《毕业——雪月花杀人游戏》（加贺恭一郎系列）（《毕业前杀人游戏》）&lt;卒业―雪月花杀人ゲーム&gt;</li>
<li>《白马山庄杀人事件》&lt;白马山荘杀人事件&gt;</li>
</ol>
<h3 id="1987年"><a href="#1987年" class="headerlink" title="1987年"></a>1987年</h3><ol>
<li>《学生街里的杀人事件》&lt;学生街の杀人&gt;（入围第41届日本推理作家协会赏）</li>
<li>《十一字杀人》<11文字の杀人></11文字の杀人></li>
</ol>
<h3 id="1988年"><a href="#1988年" class="headerlink" title="1988年"></a>1988年</h3><ol>
<li>《魔球》</li>
<li>《以眨眼干杯》&lt;ウインクで乾杯&gt; 原名&lt;香子の梦―コンパニオン杀人事件&gt; / 《香子之梦——夥伴杀人事件》</li>
<li>《浪花少年侦探团》&lt;浪花少年探侦団&gt;</li>
</ol>
<h3 id="1989年"><a href="#1989年" class="headerlink" title="1989年"></a>1989年</h3><ol>
<li>《十字豪宅的小丑》&lt;十字屋敷のピエロ&gt;</li>
<li>《沉睡的森林》&lt;眠りの森&gt;（加贺恭一郎系列）（特别说明：并不是木村拓哉主演的那部电视剧）</li>
<li>《鸟人计划》&lt;鸟人计画&gt;（入围第11届吉川英治文学新人奖）</li>
<li>《杀人现场在云端》&lt;杀人现场は云の上&gt;</li>
<li>《布鲁特斯的心脏——完全犯罪杀人接力》&lt;ブルータスの心臓―完全犯罪杀人リレー&gt;</li>
</ol>
<h3 id="1990年"><a href="#1990年" class="headerlink" title="1990年"></a>1990年</h3><ol>
<li>《侦探俱乐部》&lt;探侦倶楽部&gt; 原名 &lt;依頼人の娘&gt;《负责人的女儿》<br>本短篇集包括：<ol>
<li>伪装之夜 / 伪装の夜</li>
<li>疯狂的电击 / 罠の中</li>
<li>少女委托人 / 依頼人の娘</li>
<li>伊豆旅馆的神秘案 / 探侦の使い方</li>
<li>玫瑰与匕首 / 蔷薇とナイフ</li>
</ol>
</li>
<li>《宿命》（2004年拍摄日剧SP，柏原崇、藤木直人主演）</li>
<li>《没有凶手的杀人夜》&lt;犯人のいない杀人の夜&gt;（曾刊载于推理杂志）<ol>
<li>小小的恶作剧故事 / 小さな故意の物语（2012年日剧《东野圭吾推理系列》第八集，三浦春马主演）</li>
<li>黑暗中的两个人 / 闇の中の二人</li>
<li>舞女 / 踊り子</li>
<li>无尽之夜 / エンドレス·ナイト（2012年日剧《东野圭吾推理系列》第三集，松下奈绪主演）</li>
<li>白色凶器 / 白い凶器（2012年日剧《东野圭吾推理系列》第七集，户田惠梨香主演）</li>
<li>别了，教练 / さよならコーチ（2012年日剧《东野圭吾推理系列》第一集，唐泽寿明主演）</li>
<li>没有凶手的杀人夜 / 犯人のいない杀人の夜（2012年日剧《东野圭吾推理系列》第二集，坂口宪二主演）</li>
</ol>
</li>
<li>《面具山庄杀人事件》&lt;仮面山荘杀人事件&gt;</li>
</ol>
<h3 id="1991年"><a href="#1991年" class="headerlink" title="1991年"></a>1991年</h3><ol>
<li>《变身》&lt;变身&gt;（2005年拍摄电影，玉木宏、苍井优主演）</li>
<li>《回廊亭杀人事件》&lt;回廊亭杀人事件&gt;（2012年06月24日播出日剧SP，主演：常盘贵子）</li>
<li>《天使之耳》&lt;交通警察の夜&gt;<ol>
<li>天使之耳/ 天使の耳</li>
<li>隔离带/ 分离帯</li>
<li>危险的新叶/ 危険な若叶</li>
<li>请通过/ 通りゃんせ</li>
<li>请勿弃物/ 舍てないで</li>
<li>镜之中/ 镜の中で</li>
</ol>
</li>
</ol>
<h3 id="1992年"><a href="#1992年" class="headerlink" title="1992年"></a>1992年</h3><ol>
<li>《雪地杀机》&lt;ある闭ざされた雪の山荘で&gt;</li>
<li>《美丽的凶器》&lt;美しき凶器&gt;</li>
</ol>
<h3 id="1993年"><a href="#1993年" class="headerlink" title="1993年"></a>1993年</h3><ol>
<li>《同班同学》&lt;同级生&gt;</li>
<li>《分身》（2012年2月12日播出日剧，主演：长泽雅美）</li>
<li>《和阿忍老师说再见——浪花少年侦探团·独立篇》&lt;しのぶセンセにサヨナラ―浪花少年探侦団·独立编&gt;</li>
</ol>
<h3 id="1994年"><a href="#1994年" class="headerlink" title="1994年"></a>1994年</h3><ol>
<li>《怪人们》 / 怪しい人びと<ol>
<li>沉睡的女人 / 寝ていた女</li>
<li>让我再听一次你的判罚 / もう一度コールしてくれ</li>
<li>至死方休 / 死んだら働けない</li>
<li>蜜月之旅 / 甘いはずなのに</li>
<li>新婚照之谜 / 结婚报告（2012年日剧《东野圭吾推理系列》第九集，广末凉子主演）</li>
<li>灯塔之上 / 灯台にて</li>
<li>哥斯达黎加的冷雨 / コスタリカの雨は冷たい</li>
</ol>
</li>
<li>《我以前死去的家》&lt;むかし仆が死んだ家&gt;</li>
<li>《操纵彩虹的少年》&lt;虹を操る少年&gt;</li>
</ol>
<h3 id="1995年"><a href="#1995年" class="headerlink" title="1995年"></a>1995年</h3><ol>
<li>《平行世界·爱情故事》&lt;パラレルワールド·ラブストーリー&gt;</li>
<li>《那个时候我们是傻瓜》（散文集）&lt;あの顷ぼくらはアホでした&gt;</li>
<li>《怪笑小说》<ol>
<li>郁积电车 / 郁积电车</li>
<li>追星阿婆 / おっかけバアさん</li>
<li>一彻老爸 / 一彻おやじ</li>
<li>逆转同学会 / 逆転同窓会</li>
<li>超狸理论 / 超たぬき理论</li>
<li>无人岛大相扑转播 / 无人岛大相扑中継</li>
<li>尸台社区 / しかばね台分譲住宅</li>
<li>献给某位老爷爷的线香 / あるジーサンに线香を</li>
<li>动物家庭 / 动物家族</li>
</ol>
</li>
<li>《天空之蜂》&lt;天空の蜂&gt;（入围第17届吉川英治文学新人奖）</li>
</ol>
<h3 id="1996年"><a href="#1996年" class="headerlink" title="1996年"></a>1996年</h3><ol>
<li>《名侦探的守则》&lt;名探侦の掟&gt;（2009春季日剧，松田翔太主演）</li>
<li>《谁杀了她》（加贺恭一郎系列）&lt;どちらかが彼女を杀した&gt;</li>
<li>《毒笑小说》<ol>
<li>绑架天国 / 诱拐天国</li>
<li>Angel / エンジェル</li>
<li>手工贵妇 / 手作りマダム</li>
<li>程序警察 / マニュアル警察（世界奇妙物语 2000秋季sp，玉置浩二主演，又名《准则警察》）</li>
<li>爷爷当家 / ホームアローンじいさん</li>
<li>新郎人偶 / 花婿人形</li>
<li>女作家 / 女流作家</li>
<li>杀意使用说明书 / 杀意取扱说明书（世界奇妙物语 2010秋季sp，玉木宏、冢本高史主演）</li>
<li>补偿 / つぐない</li>
<li>光荣的证言 / 栄光の证言</li>
<li>本格推理周边鉴定秀 / 本格推理関连グッズ鉴定ショー</li>
<li>绑架电话网 / 诱拐电话网</li>
</ol>
</li>
<li>《恶意》（加贺恭一郎系列）</li>
<li>《名侦探的诅咒》&lt;名探侦の呪缚&gt;</li>
</ol>
<h3 id="1998年"><a href="#1998年" class="headerlink" title="1998年"></a>1998年</h3><ol>
<li>《侦探伽利略》（神探伽利略系列第1部）&lt;探侦ガリレオ&gt;</li>
<li>《秘密》（第52届日本推理作家协会奖、第120 届直木奖入围）</li>
</ol>
<h3 id="1999年"><a href="#1999年" class="headerlink" title="1999年"></a>1999年</h3><ol>
<li>《我杀了他》（加贺恭一郎系列）&lt;私が彼を杀した&gt;</li>
<li>《白夜行》（第122 届直木奖入围）</li>
</ol>
<h3 id="2000年"><a href="#2000年" class="headerlink" title="2000年"></a>2000年</h3><ol>
<li>《又一个谎言》 （加贺恭一郎系列） &lt;嘘をもうひとつだけ&gt;　刊载于推理杂志220-224期<ol>
<li>又一个谎言 / 嘘をもうひとつだけ</li>
<li>寒冷的灼热 / 冷たい灼热</li>
<li>第二个希望 / 第二の希望</li>
<li>疯狂计算 / 狂った计算</li>
<li>朋友的忠告 / 友の助言</li>
</ol>
</li>
<li>《预知梦》（神探伽利略系列第2部）&lt;予知梦&gt;（2007年拍摄日剧《神探伽利略》6-10集，福山雅治、柴崎幸主演）</li>
</ol>
<h3 id="2001年"><a href="#2001年" class="headerlink" title="2001年"></a>2001年</h3><ol>
<li>《单恋》&lt;片想い&gt; （第125 届直木奖入围）</li>
<li>《超·杀人事件》&lt;超·杀人事件　推理作家の苦悩&gt;（「2003年世界奇妙物语春季篇」拍摄其中一个单元故事&lt;超税金对策杀人事件&gt;，西村雅彦、大冢宁宁主演）<ol>
<li>超税金对策杀人事件 / 超税金対策杀人事件</li>
<li>超理科杀人事件 / 超理系杀人事件</li>
<li>超猜凶手小说杀人事件 / 超犯人当て小说杀人事件（问题篇·解决篇）</li>
<li>超高龄化社会杀人事件 / 超高齢化社会杀人事件</li>
<li>超预告小说杀人事件 / 超予告小说杀人事件</li>
<li>超长篇小说杀人事件 / 超长编小说杀人事件</li>
<li>魔风馆杀人事件 / 魔风馆杀人事件（超最终回·ラスト五枚）</li>
<li>超读书机器杀人事件 / 超読书机械杀人事件</li>
</ol>
</li>
<li>《圣诞阿姨》 /サンタのおばさん（絵本：絵は杉田比吕美）</li>
</ol>
<h3 id="2002年"><a href="#2002年" class="headerlink" title="2002年"></a>2002年</h3><ol>
<li>《湖畔》&lt;レイクサイド&gt;（2002年拍摄电影，药师丸博子、丰川悦司、役所广司主演）</li>
<li>《时生》&lt;トキオ&gt;（2004年拍摄日剧，樱井翔主演，剧名为「给父亲的口信」）</li>
<li>《绑架游戏》&lt;ゲームの名は诱拐&gt;（2003年拍摄电影、藤木直人、仲间由纪惠主演）</li>
</ol>
<h3 id="2003年"><a href="#2003年" class="headerlink" title="2003年"></a>2003年</h3><ol>
<li>《信》&lt;手纸&gt;（第129 届直木奖入围）（2005年拍摄电影，山田孝之、泽尻英龙华主演）</li>
<li>《我是非常勤》&lt;おれは非情勤&gt; （注：本书书名和「 非常勤」（中文意为兼任）同音，是创作者特别设定的双关语趣味）</li>
<li>《杀人之门》&lt;杀人の门&gt;</li>
</ol>
<h3 id="2004年"><a href="#2004年" class="headerlink" title="2004年"></a>2004年</h3><ol>
<li>《幻夜》（第131 届直木奖入围）（2010年秋季档日剧，深田恭子、冢本高史主演）</li>
<li>《挑战？》（散文集）&lt;ちゃれんじ&gt;（散文集）</li>
<li>《彷徨之刃》&lt;さまよう刃&gt;（2009年改编为电影，竹野内丰主演）</li>
</ol>
<h3 id="2005年"><a href="#2005年" class="headerlink" title="2005年"></a>2005年</h3><ol>
<li>《黑笑小说》<ol>
<li>又一次助跑 / もうひとつの助走</li>
<li>线香花火 / 线香花火</li>
<li>过去的人 / 过去の人</li>
<li>评审会 / 选考会</li>
<li>巨乳妄想综合征 / 巨乳妄想症候群</li>
<li>无能药 / インポグラ</li>
<li>显微眼 / みえすぎ</li>
<li>钟情喷雾 / モテモテ·スプレー</li>
<li>灰姑娘白夜行 / シンデレラ白夜行</li>
<li>跟踪狂入门 / ストーカー入门</li>
<li>临界家族 / 临界家族</li>
<li>不笑的人 / 笑わない男</li>
<li>奇迹之照 / 奇迹の一枚</li>
</ol>
</li>
<li>《嫌疑犯X的献身》（神探伽利略系列第3部）&lt;容疑者Xの献身&gt;</li>
<li>《科学》（散文集）&lt;さいえんす&gt;</li>
</ol>
<h3 id="2006年"><a href="#2006年" class="headerlink" title="2006年"></a>2006年</h3><ol>
<li>《梦回都灵》（散文集）&lt;梦はトリノをかけめぐる&gt;</li>
<li>《红手指》（加贺恭一郎系列） &lt;赤い指&gt;（2011年冬季档日剧SP，阿部宽、黑木明纱主演）</li>
<li>《使命与心的极限》&lt;使命と魂のリミット&gt; （2011秋季档日剧SP，石原里美、速水重道主演）</li>
</ol>
<h3 id="2007年"><a href="#2007年" class="headerlink" title="2007年"></a>2007年</h3><ol>
<li>《也许是最后的寒暄》&lt;たぶん最後の御挨拶&gt;（散文集）</li>
<li>《黎明之街》&lt;夜明けの街で&gt;（2011年拍摄电影，深田恭子、岸谷五朗主演）</li>
<li>《濒死之眼》&lt;ダイイング·アイイ&gt;</li>
</ol>
<h3 id="2008年"><a href="#2008年" class="headerlink" title="2008年"></a>2008年</h3><ol>
<li>《流星之绊》&lt;流星の绊&gt;（2008年拍摄日剧，二宫和也、锦户亮、户田惠梨香主演）</li>
<li>《伽利略的苦恼》（神探伽利略系列第4部）&lt;ガリレオの苦悩&gt;</li>
<li>《圣女的救济》（神探伽利略系列第5部）&lt;圣女の救済&gt;</li>
</ol>
<h3 id="2009年"><a href="#2009年" class="headerlink" title="2009年"></a>2009年</h3><ol>
<li>《悖论13》台版译《异变13秒》&lt;パラドックス13&gt;</li>
<li>《新参者》（加贺恭一郎系列）（2010年拍摄日剧，阿部宽、黑木明纱主演）</li>
<li>《美丽的凶器》</li>
</ol>
<h3 id="2010年"><a href="#2010年" class="headerlink" title="2010年"></a>2010年</h3><ol>
<li>《布谷鸟的蛋是谁的》&lt;カッコウの卵は谁のもの&gt; 在《小说宝石》上连载时原题《フェイク》</li>
<li>《白金数据》&lt;プラチナデータ&gt;（2012年拍摄电影，二宫和也主演）</li>
<li>《白银杰克》&lt; 白银ジャック&gt;</li>
</ol>
<h3 id="2011年"><a href="#2011年" class="headerlink" title="2011年"></a>2011年</h3><ol>
<li>《你旁边是谁》&lt;あの顷の谁か&gt;<ol>
<li>全是字谜 / シャレードがいっぱい（2012年日剧《东野圭吾推理系列》第六集，长泽雅美主演）</li>
<li>Reiko和玲子 / 玲子とレイコ（2012年日剧《东野圭吾推理系列》第四集，观月阿丽莎主演）</li>
<li>再生魔术之女 / 再生魔术の女 （2012年日剧《东野圭吾推理系列》第十一集，铃木京香主演）</li>
<li>再见，“爸爸” / さよなら『お父さん』</li>
<li>名侦探退场 / 名探侦退场 </li>
<li>母老虎 / 女も虎も</li>
<li>好困，我不想死 / りたい死にたくない </li>
<li>20年的约定 / 二十年目の约束（2012年日剧《东野圭吾推理系列》第十集，筱原凉子主演）</li>
</ol>
</li>
<li>《麒麟之翼》（加贺恭一郎系列）&lt;麒麟の翼&gt;（加贺恭一郎系列）</li>
<li>《牛奶箱的回答》&lt;回答は牛乳箱に&gt;（短篇 出自《小说 野性时代》 第89号）</li>
<li>《听心》&lt;心聴&gt;（短篇 出自《オール读物》2011年04月号）</li>
<li>《盛夏的方程式》（神探伽利略系列第6部）&lt;真夏の方程式&gt;</li>
<li>《假面舞馆》&lt;マスカレード·ホテル&gt; 暂定2012年9月9日出版</li>
<li>《歪笑小说》</li>
</ol>
<h3 id="2012年"><a href="#2012年" class="headerlink" title="2012年"></a>2012年</h3><ol>
<li>《虚像的小丑》（神探伽利略系列第7部）&lt;虚像の道化师 ガリレオ 7&gt;</li>
<li>《杂货店的奇迹》</li>
<li>《那个时候的谁》</li>
<li>《禁断的魔术》（神探伽利略系列第8部）&lt;禁断の魔术 ガリレオ8&gt;</li>
</ol>
<h3 id="2013年"><a href="#2013年" class="headerlink" title="2013年"></a>2013年</h3><ol>
<li>《梦幻花》（むげんばな）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了几篇 东野圭吾 的小说, 都还蛮有意思的。 像 《嫌疑人X的献身》, 《流星之绊》,《毕业》啊 等等,好多都记不住名字了。&lt;/p&gt;
&lt;p&gt;于是决定把他的全集整理一下,留着有空都看一遍~&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;加贺恭一郎系列&quot;&gt;&lt;a href=&quot;#加贺恭一
    
    </summary>
    
      <category term="文学" scheme="http://blog.ochukai.me/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="文学" scheme="http://blog.ochukai.me/tags/%E6%96%87%E5%AD%A6/"/>
    
      <category term="日本文学" scheme="http://blog.ochukai.me/tags/%E6%97%A5%E6%9C%AC%E6%96%87%E5%AD%A6/"/>
    
      <category term="东野圭吾" scheme="http://blog.ochukai.me/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="东野圭吾作品全集" scheme="http://blog.ochukai.me/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE%E4%BD%9C%E5%93%81%E5%85%A8%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Splice 和 Slice 的区别</title>
    <link href="http://blog.ochukai.me/ths-difference-between-splice-and-slice/"/>
    <id>http://blog.ochukai.me/ths-difference-between-splice-and-slice/</id>
    <published>2016-07-11T02:52:16.000Z</published>
    <updated>2016-11-22T01:40:09.766Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一遍介绍 <code>splice()</code> 方法的，这一次又遇到了 <code>slice()</code>, 这两个太像了, 首先看这两个意思吧：</p>
<blockquote>
<p>splice [splais]<br>n. 接合；结婚<br>vt. 拼接；接合；使结婚</p>
</blockquote>
<p>和  </p>
<blockquote>
<p>slice [slais]<br>n. 薄片；部分；菜刀，火铲<br>vt. 切下；把…分成部分；将…切成薄片<br>vi. 切开；割破</p>
</blockquote>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>slice()</code> 方法可从已有的数组中返回选定的元素。这个函数有两个参数 <code>slice(start, end)</code> 会返回一个从 <code>start</code> 到 <code>end</code> 之前元素的新数组， 如果 <code>end</code> 是<code>负数</code>，就从数组末尾倒着数, 如果 end 没有设置，就返回从 start 到数组末尾组成的新数组咯~</p>
<p>总之这是一个返回新数组的函数，知识返回而已，不会改变原来的数组，而 <code>splice</code> 方法则会改变原来的数组.</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>var arr = new Array(3)
arr[0] = &quot;George&quot;
arr[1] = &quot;John&quot;
arr[2] = &quot;Thomas&quot;
arr[3] = &quot;James&quot;
arr[4] = &quot;Adrew&quot;
arr[5] = &quot;Martin&quot;

console.log(arr.slice(4)) // [&quot;Adrew&quot;, &quot;Martin&quot;] == arr.slice(4, 6)
console.log(arr.slice(0, -4)) // [&quot;George&quot;, &quot;John&quot;] == arr.slice(0, 2)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一遍介绍 &lt;code&gt;splice()&lt;/code&gt; 方法的，这一次又遇到了 &lt;code&gt;slice()&lt;/code&gt;, 这两个太像了, 首先看这两个意思吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;splice [splais]&lt;br&gt;n. 接合；结婚&lt;br&gt;vt
    
    </summary>
    
      <category term="Javascript" scheme="http://blog.ochukai.me/categories/javascript/"/>
    
    
      <category term="splice" scheme="http://blog.ochukai.me/tags/splice/"/>
    
      <category term="slice" scheme="http://blog.ochukai.me/tags/slice/"/>
    
  </entry>
  
  <entry>
    <title>上层滚动 下层不摇滚</title>
    <link href="http://blog.ochukai.me/prevent-deep-div-scroll-with-the-top-element/"/>
    <id>http://blog.ochukai.me/prevent-deep-div-scroll-with-the-top-element/</id>
    <published>2016-06-23T03:12:27.000Z</published>
    <updated>2016-11-22T01:40:09.751Z</updated>
    
    <content type="html"><![CDATA[<p>最近写手机页面颇多, 经常有弹出框, 或者下拉列表, 如果弹框或者下拉列表的内容太多,出现了滚动条, 恰好外面的内容也很多,也有滚动条的话,就会出现一种情况:</p>
<p><img src="../images/scroll-1.png" alt="例子"></p>
<p>比如上图, 当用力划一下屏幕, 下拉框滚到底了之后, <strong>body</strong> 随之也开始滚, 很讨厌。出现过好多次了, 而且测试逼我太紧~</p>
<h2 id="我要解决这个问题啊"><a href="#我要解决这个问题啊" class="headerlink" title="我要解决这个问题啊"></a>我要解决这个问题啊</h2><p>其实很简单, 只要弹出下拉列表的时候让下层的元素不能滚动就好了。</p>
<pre><code class="css">.modal-open { 
  overflow: hidden;
}
</code></pre>
<p>js 的话就这么写:</p>
<pre><code class="js">  function show($div) {
    $(&#39;body&#39;).addClass(&#39;modal-open&#39;);
    // ...
  }

  function hide($div) {
    $(&#39;body&#39;).removeClass(&#39;modal-open&#39;);
    // ...
  }
</code></pre>
<p>以上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写手机页面颇多, 经常有弹出框, 或者下拉列表, 如果弹框或者下拉列表的内容太多,出现了滚动条, 恰好外面的内容也很多,也有滚动条的话,就会出现一种情况:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/scroll-1.png&quot; alt=&quot;例子&quot;&gt;&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zepto 插件写法</title>
    <link href="http://blog.ochukai.me/zepto-plugin/"/>
    <id>http://blog.ochukai.me/zepto-plugin/</id>
    <published>2016-06-20T06:32:33.000Z</published>
    <updated>2016-11-22T01:40:09.782Z</updated>
    
    <content type="html"><![CDATA[<p>一般是这样的…  比较水, 并没有怎么写过.</p>
<p>我只是把 bootstrap 的 button 组件改了一下, 删掉了 data-api 部分, 感觉这样该够用了。</p>
<pre><code class="js">
+function ($) {
  &#39;use strict&#39;;

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element);
    this.options   = $.extend({}, Button.DEFAULTS, options);
  }

  Button.DEFAULTS = {
    loadingText: &#39;loading...&#39;;
  }

  Button.prototype.setState = function (state) {};

  Button.prototype.toggle = function () {};


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this),
          lookup   = $.fn.button.lookup,
          instance = lookup[$this.data(&#39;bs.button&#39;)];

      if (!instance) {
        lookup[++lookup.i] = (instance = new Button(this, options));
        $this.data(&#39;bs.button&#39;, lookup.i);
      }

      // button method
      // if (option == &#39;toggle&#39;) {
      //   data.toggle();
      // } else if (option) {
      //   data.setState(option);
      // }
    });
  }

  var old = $.fn.button;

  $.fn.button             = Plugin;
  $.fn.button.lookup      = { i: 0 };
  $.fn.button.Constructor = Button;


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old;
    return this;
  };

} (Zepto);
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般是这样的…  比较水, 并没有怎么写过.&lt;/p&gt;
&lt;p&gt;我只是把 bootstrap 的 button 组件改了一下, 删掉了 data-api 部分, 感觉这样该够用了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;
+function ($) {
  &amp;#3
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.ochukai.me/categories/javascript/"/>
    
    
      <category term="zepto" scheme="http://blog.ochukai.me/tags/zepto/"/>
    
  </entry>
  
  <entry>
    <title>使用 formData 提交表单和上传图片</title>
    <link href="http://blog.ochukai.me/formdata-in-action/"/>
    <id>http://blog.ochukai.me/formdata-in-action/</id>
    <published>2016-04-11T07:34:57.000Z</published>
    <updated>2016-11-22T01:40:09.735Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一个表单，需要提交好多信息和一些图片，后台的同学说要图片随着表单一起提交。那就不能用 ajax 单张上传了~</p>
<p>图片的话，最多可以选8张，选中了的也可以取消掉，因为并没有传到服务器，所以删除很easy。</p>
<p>然后我就想到了可以用 FormData 来做，因为之前好像用过，感觉很方便。</p>
<h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><blockquote>
<p>The FormData interface provides a way to easily construct a set of <code>key/value</code> pairs representing form fields and their values, which can then be easily sent using the <code>XMLHttpRequest.send()</code> method. It uses the same format a form would use if the encoding type were set to “multipart/form-data”.</p>
</blockquote>
<p>如果使用 jQuery 提交 formData 的话，大致像这样：</p>
<pre><code class="js">$.ajax({
  url        : url,
  type       : &#39;POST&#39;,
  data       : formData,
  // 下面这两条需要特别注意
  processData: false,
  contentType: false,
  success(data) {
    // ...
  },
  error(xhr) {
    // ...
  }
});
</code></pre>
<p>就是把 formData 作为 data 发送到后台就好了，如果要构造一个 formData 对象的话，也很简单呢</p>
<pre><code class="js">
var formdata = new FormData();
formData.append(&#39;ticket_id&#39;, 1);
</code></pre>
<p>如果放文件在 formData 里面的话呢，也没有太复杂的地方：</p>
<pre><code class="js">// html
// &lt;input
//   ref=&quot;input-image&quot;
//   accept=&quot;image/*&quot;
//   onChange={ this.onImageSelected }
//   type=&quot;file&quot;
// /&gt;

// ....
isImage: function (file) {
  // (!src.type.match(/image.*/)
  var type = &#39;|&#39; + file.type.slice(file.type.lastIndexOf(&#39;/&#39;) + 1) + &#39;|&#39;;
  return &#39;|jpg|png|jpeg|bmp|gif|&#39;.indexOf(type) !== -1;
},

onImageSelected(e) {
  var file = e.target.files[0];
  console.log(&#39;select image&#39;, file);

  if (!this.isImage(file)) {
    Modal.error({ title: &#39;请选择一张图片&#39; });
    return;
  }

  this.props.onImageSelected(file);
}
// ...

// 放多个也可以~
formData.append(&#39;file1&#39;, file1)
formData.append(&#39;file2&#39;, file2)
</code></pre>
<p>对了，因为我把上传文件的 input 隐藏掉了，显示出来了是一个 加号 的图标，所以如果要触发 input 的点击事件的话：</p>
<pre><code class="js">onItemClick() {
  const input = findDOMNode(this.refs[&#39;input-image&#39;]);
  input.click();
},
</code></pre>
<h3 id="生成-formData"><a href="#生成-formData" class="headerlink" title="生成 formData"></a>生成 formData</h3><p>一个一个的 append 可能速度太慢了，而且需要每个都写一遍，其实生成的 formData 的方式还是蛮多的：</p>
<pre><code class="js">// 1
var form =  document.getElementById(&quot;form&quot;);
var formdata = new FormData(form);

// 2
var form =  document.getElementById(&quot;form&quot;);
var formdata = form.getFormData();
</code></pre>
<p>好了，没了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了一个表单，需要提交好多信息和一些图片，后台的同学说要图片随着表单一起提交。那就不能用 ajax 单张上传了~&lt;/p&gt;
&lt;p&gt;图片的话，最多可以选8张，选中了的也可以取消掉，因为并没有传到服务器，所以删除很easy。&lt;/p&gt;
&lt;p&gt;然后我就想到了可以用 FormDat
    
    </summary>
    
      <category term="form" scheme="http://blog.ochukai.me/categories/form/"/>
    
      <category term="JavaScript" scheme="http://blog.ochukai.me/categories/form/javascript/"/>
    
    
      <category term="formData" scheme="http://blog.ochukai.me/tags/formdata/"/>
    
      <category term="ajax" scheme="http://blog.ochukai.me/tags/ajax/"/>
    
      <category term="image upload" scheme="http://blog.ochukai.me/tags/image-upload/"/>
    
  </entry>
  
  <entry>
    <title>菜单下面的小精灵</title>
    <link href="http://blog.ochukai.me/menu-with-moved-elfish/"/>
    <id>http://blog.ochukai.me/menu-with-moved-elfish/</id>
    <published>2016-03-21T08:05:51.000Z</published>
    <updated>2016-11-22T01:40:09.751Z</updated>
    
    <content type="html"><![CDATA[<p>有些网站的导航下面会有一到杠，鼠标在各个导航之间移动的时候，这一道杠也会跟着动，很好看，就像这个</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="PNbGZQ" data-default-tab="result" data-user="ochukai" class="codepen">See the Pen <a href="http://codepen.io/ochukai/pen/PNbGZQ/" target="_blank" rel="external">ooo-nav</a> by Oliver (<a href="http://codepen.io/ochukai" target="_blank" rel="external">@ochukai</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>我把她叫做小精灵。</p>
<hr>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>实现这个其实不难，当鼠标移动到某一个菜单上面时，小精灵滑入（至于方向，如果鼠标从右边进入菜单，那就从右向左滑），然后当鼠标移出时，小精灵跟着也移出菜单， 同时如果鼠标恰好移进了另一个菜单，下一个菜单的进入动画也开始播放，连续起来的话就像是小精灵跟着过来了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>菜单的话当然是用 ul 来实现了</p>
<pre><code class="html">&lt;ul class=&quot;nav&quot;&gt;
  &lt;li&gt;我的&lt;/li&gt;
  &lt;li&gt;导航栏&lt;/li&gt;
  &lt;li&gt;非常&lt;/li&gt;
  &lt;li&gt;牛逼&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h3 id="小精灵"><a href="#小精灵" class="headerlink" title="小精灵"></a>小精灵</h3><p>这个小精灵该怎么实现呢, 开始时我打算用 <code>border</code> 来实现，试了一下之后才发现，并不理想，因为当鼠标 hover 时，border 变化，内容也会随着动，很丑。</p>
<p>于是我就想用 <code>after</code> 这个伪元素来实现，因为之前并没用过，感觉蛮新鲜的。</p>
<p>使用 <code>after</code> 最重要的地方也是前提，就是 <code>content: &#39;&#39;</code>，如果没有这一句，不管怎么修饰 <code>after</code> 的样式，都是徒劳。</p>
<p>写完之后的样子大概是这样</p>
<pre><code class="less">  &gt; li {
    float:left;
    display: inline-block;
    padding: 10px 20px;
    cursor: pointer;
    position: relative;
    overflow: hidden;

    &amp;:after {
      content: &#39;&#39;;
      height: 3px;
      position: absolute;
      bottom: 0;
    }
  }
</code></pre>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>根据上面的原理，如果想实现的话，大概只需要写四个动画</p>
<ul>
<li>小精灵从右向左进入菜单</li>
<li>小精灵从右向左移出菜单</li>
<li>小精灵从左向右进入菜单</li>
<li>小精灵从左向右移出菜单</li>
</ul>
<p>我打算使用 <code>width</code> 的变化来模拟小精灵的滑动效果，假如是从左向右， css 就像下面这样：</p>
<pre><code class="css">@keyframes slide-in {
  from { width: 0; }
  to { width: 100%; }
}

.slide-in-from-left:after,
.slide-out-from-left:after {
  left: 0; // 初始位置在左边，宽度为 0，宽度逐渐变大
}

.slide-in-from-left:after,
.slide-in-from-right:after {
  animation-name: slide-in;
  animation-timing-function: cubic-bezier(0.65, 0.05, 0.36, 1);
}
</code></pre>
<h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><p>css 写完了，不过我要识别鼠标进入或离开的方向，也就是要判断鼠标是从左边进入还是从右边进入，是从左边移出还是从右边移出。</p>
<p>于是， 要写一些 js 来判断</p>
<pre><code class="js">$(function() {

  var classList = [
        &#39;slide-in-from-left&#39;,
        &#39;slide-in-from-right&#39;,
        &#39;slide-out-from-right&#39;,
        &#39;slide-out-from-left&#39;
      ].join(&#39; &#39;);

  $(&#39;ul.nav&#39;)
    .on(&#39;mouseenter&#39;, &#39;li&#39;, function(e) {
      var $this = $(this);
      var width = $this.outerWidth();
      var xx = e.offsetX;
      var className = (xx &lt; (width / 2))
                    ? &#39;slide-in-from-left&#39;
                    : &#39;slide-in-from-right&#39;;

      $this.removeClass(classList).addClass(className);      
    })
    .on(&#39;mouseleave&#39;, &#39;li&#39;, function(e) {
      var $this = $(this);
      var width = $this.outerWidth();
      var xx = e.offsetX;
      var className = (xx &lt; (width / 2))
                    ? &#39;slide-out-from-left&#39;
                    : &#39;slide-out-from-right&#39;;
      $this.removeClass(classList).addClass(className);
    });

});
</code></pre>
<p>这样就写完了，再把开头的例子放上吧。</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="PNbGZQ" data-default-tab="result" data-user="ochukai" class="codepen">See the Pen <a href="http://codepen.io/ochukai/pen/PNbGZQ/" target="_blank" rel="external">ooo-nav</a> by Oliver (<a href="http://codepen.io/ochukai" target="_blank" rel="external">@ochukai</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些网站的导航下面会有一到杠，鼠标在各个导航之间移动的时候，这一道杠也会跟着动，很好看，就像这个&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p data-height=&quot;268&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;PNbGZQ&quot; data-default-t
    
    </summary>
    
      <category term="CSS Animation" scheme="http://blog.ochukai.me/categories/css-animation/"/>
    
      <category term="CSS" scheme="http://blog.ochukai.me/categories/css-animation/css/"/>
    
    
      <category term="nav" scheme="http://blog.ochukai.me/tags/nav/"/>
    
  </entry>
  
  <entry>
    <title>Queue Anim 列表</title>
    <link href="http://blog.ochukai.me/css-animation-queue-list/"/>
    <id>http://blog.ochukai.me/css-animation-queue-list/</id>
    <published>2016-03-03T09:45:24.000Z</published>
    <updated>2016-11-22T01:40:09.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h1><p>基本写法是一个开始状态和一个结束状态：</p>
<pre><code class="css">@keyframes demo-anim {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}
</code></pre>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="QNbBOy" data-default-tab="result" data-user="ochukai" class="codepen">See the Pen <a href="http://codepen.io/ochukai/pen/QNbBOy/" target="_blank" rel="external">QNbBOy</a> by Oliver (<a href="http://codepen.io/ochukai" target="_blank" rel="external">@ochukai</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<blockquote>
<p>其中 <code>animation-iteration-count: number or infinite;</code> 可以设置循环次数，infinite为无限次</p>
</blockquote>
<p>还可以定义的很详细：</p>
<pre><code class="css">@keyframes demo-anim {
  from {
    transform: translate(0, 0);
  }
  20% {
    transform: translate(20, 20);
  }
  40% {
    transform: translate(40, 0);
  }
  60% {
    transform: translate(60, 20);
  }
  80% {
    transform: translate(80, 0);
  }
  to {
    transform: translate(100, 20);
  }
}
</code></pre>
<h1 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h1><blockquote>
<p>animation-fill-mode : none | forwards | backwards | both;</p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>不改变默认行为。</td>
</tr>
<tr>
<td>forward</td>
<td>当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。</td>
</tr>
<tr>
<td>backwards</td>
<td>在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。</td>
</tr>
<tr>
<td>both</td>
<td>向前和向后填充模式都被应用。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>用到的知识点就是上面两个，下面开始写。</p>
</blockquote>
<h1 id="Queue-in-List"><a href="#Queue-in-List" class="headerlink" title="Queue-in List"></a>Queue-in List</h1><p>我要写的效果是一个列表，当列表显示时，其子项逐个出现，从右向左滑入，透明度也由浅变深。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先写一个使 li 从左向右滑入的效果，然后再给需要稍晚滑入的 li 加上 <code>animation-delay</code> 就好了。</p>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><pre><code class="css">/* 定义 li 样式 */
li {
  width: 200px;
  height: 30px;
  background-color: #ccc;
  margin-top: 2px;
  opacity: 0; /* 默认是隐藏的 */
}

/* 定义动画 */
@keyframes queue-in {
  from {
    /* 开始时 在左边 */
    transform: translateX(40px);
  }

  to {
    opacity: 1;
    transform: translateX(0);
  }
}

/* 调用动画 */
.list-queue-in &gt; li {
  animation-name: queue-in;
  animation-duration: .3s;
  /* 这一行就表示动画结束时元素的状态就是动画的最后一帧 */
  animation-fill-mode: forwards;
  animation-timing-function: ease-in;
}
</code></pre>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>这是 进入状态时的 html</p>
<pre><code class="html">&lt;ul class=&quot;list-queue-in&quot;&gt;
  &lt;li class=&quot;list-ad-0&quot; key=&quot;0&quot;&gt;1&lt;/li&gt;
  &lt;li class=&quot;list-ad-1&quot; key=&quot;1&quot;&gt;2&lt;/li&gt;
  &lt;li class=&quot;list-ad-2&quot; key=&quot;2&quot;&gt;3&lt;/li&gt;
  &lt;li class=&quot;list-ad-3&quot; key=&quot;2&quot;&gt;4&lt;/li&gt;
  &lt;li class=&quot;list-ad-4&quot; key=&quot;2&quot;&gt;5&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<blockquote>
<p>这样的话，li 已经可以从右向左滑入了，但是，是在一起滑入的，我需要他们分开~</p>
</blockquote>
<h2 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h2><p><code>list-ad-0</code> 这个东西就是提前定义好的 <code>animation-delay</code>，比如：</p>
<pre><code class="css">.list-ad-0 {
  -webkit-animation-delay: 0s;
          animation-delay: 0s;
}

.list-ad-1 {
  -webkit-animation-delay: 0.1s;
          animation-delay: 0.1s;
}
</code></pre>
<p>然后，他们就可以一个接一个的滑了~</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>所有的代码都在这里，就是这样的效果：</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="zqYgxb" data-default-tab="result" data-user="ochukai" class="codepen">See the Pen <a href="http://codepen.io/ochukai/pen/zqYgxb/" target="_blank" rel="external">zqYgxb</a> by Oliver (<a href="http://codepen.io/ochukai" target="_blank" rel="external">@ochukai</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;keyframes&quot;&gt;&lt;a href=&quot;#keyframes&quot; class=&quot;headerlink&quot; title=&quot;@keyframes&quot;&gt;&lt;/a&gt;@keyframes&lt;/h1&gt;&lt;p&gt;基本写法是一个开始状态和一个结束状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class
    
    </summary>
    
      <category term="CSS" scheme="http://blog.ochukai.me/categories/css/"/>
    
    
      <category term="css" scheme="http://blog.ochukai.me/tags/css/"/>
    
      <category term="animation" scheme="http://blog.ochukai.me/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>戦艦の女の子 の 航母 - 诶塞克斯</title>
    <link href="http://blog.ochukai.me/esekesu-senkanno-onnanoko/"/>
    <id>http://blog.ochukai.me/esekesu-senkanno-onnanoko/</id>
    <published>2016-03-03T05:49:03.000Z</published>
    <updated>2016-11-22T01:40:09.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="战舰少女"><a href="#战舰少女" class="headerlink" title="战舰少女"></a>战舰少女</h2><p>首先让我们认识一下这个游戏的名字：</p>
<blockquote>
<p>戦艦の女の子 【せんかんのおんなのこ】【senkannoonnanoko】</p>
</blockquote>
<h2 id="航空母舰"><a href="#航空母舰" class="headerlink" title="航空母舰"></a>航空母舰</h2><p>还有航空母舰这个单词</p>
<blockquote>
<p>航空母艦日【こうくうぼかん】【koukuubokann】  </p>
<p>航空母舰。（航空機を搭載し、これを発着させるための飛行甲板および格納庫・修理設備などを備えた軍艦。今日、水上兵力の中核。略称、空母。）</p>
</blockquote>
<h2 id="埃塞克斯"><a href="#埃塞克斯" class="headerlink" title="埃塞克斯"></a>埃塞克斯</h2><p>下面进入正题，就是我很喜欢但是还咩有得到的 - 埃塞克斯</p>
<p><img src="..//images/aise-normal.png" alt="正常"><br><img src="..//images/aise-broken.png" alt="正常"></p>
<h2 id="建造公式"><a href="#建造公式" class="headerlink" title="建造公式"></a>建造公式</h2><ol>
<li>标准航母公式：400,600,600,400（基本上赌航母都用这个）</li>
<li>低费航母公式：300,30,400,300（当资源不足时可用）</li>
<li>常用玄学公式：400 600 650 430（目前出货率极高的公式）</li>
<li>500 130 600 400（据说出货率更高~）</li>
</ol>
<h2 id="建造时间"><a href="#建造时间" class="headerlink" title="建造时间"></a>建造时间</h2><p>4 个小时</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;战舰少女&quot;&gt;&lt;a href=&quot;#战舰少女&quot; class=&quot;headerlink&quot; title=&quot;战舰少女&quot;&gt;&lt;/a&gt;战舰少女&lt;/h2&gt;&lt;p&gt;首先让我们认识一下这个游戏的名字：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;戦艦の女の子 【せんかんのおんなのこ】【senk
    
    </summary>
    
      <category term="戦艦の女の子" scheme="http://blog.ochukai.me/categories/%E6%88%A6%E8%89%A6%E3%81%AE%E5%A5%B3%E3%81%AE%E5%AD%90/"/>
    
    
      <category term="埃塞克斯" scheme="http://blog.ochukai.me/tags/%E5%9F%83%E5%A1%9E%E5%85%8B%E6%96%AF/"/>
    
      <category term="航母" scheme="http://blog.ochukai.me/tags/%E8%88%AA%E6%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>Scss 里面的 for 循环</title>
    <link href="http://blog.ochukai.me/for-in-scss/"/>
    <id>http://blog.ochukai.me/for-in-scss/</id>
    <published>2016-03-03T05:40:35.000Z</published>
    <updated>2016-11-22T01:40:09.735Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个动画效果，使 ul 下面的 li 逐个进入，就像下图<br><img src="../images/li-queue-in.png" alt=""></p>
<p>做这个效果用到了 css 的 animation 中 <code>animation-delay</code>，给 li 设置入场动画后，再给 li 设置 <code>animation-delay</code>，像这样：</p>
<pre><code class="css">.li-animation-delay-1 {
  animation-delay: 0.1s;
}
</code></pre>
<p>并且每一个 li 的 animation-delay 都比前一个 li 的长 .1s，也就达到了后面的 li 的入场动画后播放的效果。</p>
<p>因为 li 的数量也不确定，所以我打算批量生成一些 <code>li-animation-delay-*</code>, 查了一下 scss 正好有 for 的用法：</p>
<pre><code class="scss">@for $index from 0 to 10 {
  .list-ad-#{$index} {
    animation-delay: $index * 0.1#{s};
  }
}
</code></pre>
<p>其中，<code>#{***}</code> 的作用的把字符串原封不动的输出。</p>
<pre><code>#{s} --&gt; s
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个动画效果，使 ul 下面的 li 逐个进入，就像下图&lt;br&gt;&lt;img src=&quot;../images/li-queue-in.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;做这个效果用到了 css 的 animation 中 &lt;code&gt;animation-delay&lt;
    
    </summary>
    
      <category term="SASS" scheme="http://blog.ochukai.me/categories/sass/"/>
    
    
      <category term="scss" scheme="http://blog.ochukai.me/tags/scss/"/>
    
      <category term="for" scheme="http://blog.ochukai.me/tags/for/"/>
    
  </entry>
  
  <entry>
    <title>在微信网页上的电话号码</title>
    <link href="http://blog.ochukai.me/telephone-number-not-recognize-in-wx/"/>
    <id>http://blog.ochukai.me/telephone-number-not-recognize-in-wx/</id>
    <published>2016-02-26T10:36:25.000Z</published>
    <updated>2016-11-22T01:40:09.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="电话好不不想被识别"><a href="#电话好不不想被识别" class="headerlink" title="电话好不不想被识别"></a>电话好不不想被识别</h3><p>在网页中的比较长的数字会被微信浏览器自动识别为电话号码，稍不注意可能就使页面变得很难看，与是，在 header 里面加上下面两个 meta 就电话号码就不会被识别了。</p>
<pre><code class="html">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt;
&lt;meta http-equiv=&quot;x-rim-auto-match&quot; content=&quot;none&quot;&gt;
</code></pre>
<h3 id="如果要识别呢？"><a href="#如果要识别呢？" class="headerlink" title="如果要识别呢？"></a>如果要识别呢？</h3><p>加一个 <code>tel//***</code> 就可以了。</p>
<pre><code class="html">&lt;div class=&quot;telephone&quot;&gt;
    &lt;p&gt;苹果妹妹专线&lt;/p&gt;
    &lt;a href=&quot;tel://4000630086&quot;&gt;400-063-0086&lt;/a&gt;
&lt;/div&gt;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;电话好不不想被识别&quot;&gt;&lt;a href=&quot;#电话好不不想被识别&quot; class=&quot;headerlink&quot; title=&quot;电话好不不想被识别&quot;&gt;&lt;/a&gt;电话好不不想被识别&lt;/h3&gt;&lt;p&gt;在网页中的比较长的数字会被微信浏览器自动识别为电话号码，稍不注意可能就使页面变得很难
    
    </summary>
    
      <category term="微信开发" scheme="http://blog.ochukai.me/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信开发" scheme="http://blog.ochukai.me/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>杀死正在占有你端口的小程序</title>
    <link href="http://blog.ochukai.me/kill-process/"/>
    <id>http://blog.ochukai.me/kill-process/</id>
    <published>2016-02-25T10:38:07.000Z</published>
    <updated>2016-12-08T11:50:26.299Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 mac 上用 terminal 启动 python 的时候经常会提示我，端口被占用了，像这样</p>
<pre><code class="bash">0 errors found
February 25, 2016 - 18:25:21
Django version 1.6.7, using settings &#39;green.settings&#39;
Starting development server at http://0.0.0.0:8000/
Quit the server with CONTROL-C.
Error: That port is already in use.
</code></pre>
<pre><code>ps aux | grep python
</code></pre><pre><code class="shell">(kkh)➜  green git:(feature/shopping_mall_womens_day) ✗ ps aux | grep python
Oliver          23232   0.0  0.0  2434840    752 s002  S+    5:25下午   0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn python
Oliver          23103   0.0  0.8  2550628  66364 s002  S     5:23下午   0:02.23 /Users/Oliver/dev/kkh/bin/python manage.py runserver 0.0.0.0:8000
</code></pre>
<pre><code class="bash">kill 23103
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 mac 上用 terminal 启动 python 的时候经常会提示我，端口被占用了，像这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;0 errors found
February 25, 2016 - 18:25:21
Django version
    
    </summary>
    
      <category term="Linux" scheme="http://blog.ochukai.me/categories/linux/"/>
    
    
      <category term="端口占用" scheme="http://blog.ochukai.me/tags/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>战舰少女基础知识及部分公式</title>
    <link href="http://blog.ochukai.me/battleship-girls/"/>
    <id>http://blog.ochukai.me/battleship-girls/</id>
    <published>2016-02-22T16:07:25.000Z</published>
    <updated>2016-11-22T01:40:09.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>缩写</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>战列舰</td>
<td>BB</td>
<td>大炮巨舰的典范，高火力、高血量、高护甲。是游戏中后期推图的主力。</td>
</tr>
<tr>
<td>战列巡洋舰</td>
<td>BC</td>
<td>战列舰的缩减版本，火力、血量、护甲略低于战列舰，拥有相对高的防空属性，优点是全部是高速舰，推图上有优势。</td>
</tr>
<tr>
<td>正规航母</td>
<td>CV</td>
<td>高索敌，有开幕战，多一轮攻击，受装备影响大，夜间无法攻击。</td>
</tr>
<tr>
<td>轻型航母</td>
<td>CVL</td>
<td>正规航母的缩水版，装甲低下，可反潜，搭载数量低，作用是前期舰队补充。</td>
</tr>
<tr>
<td>浅水重炮舰</td>
<td>BM</td>
<td>游戏中只有两艘，火力高，可以装长距离的主炮，白天可以来两发，消耗低，本来可以用来打捞保姆，之后有改过，护甲变低，基本上没人用了。</td>
</tr>
<tr>
<td>潜艇</td>
<td>SS</td>
<td>同样为数不多，低闪避，高鱼雷，只有具备反潜能力的舰船才能打到，夜战能力高!升到11级后有开幕雷击的能力。</td>
</tr>
<tr>
<td>重巡洋舰</td>
<td>CA</td>
<td>夜战优秀，闪避中上，部分能够发射鱼雷，消耗较，欺负小学生的神器。</td>
</tr>
<tr>
<td>轻巡洋舰</td>
<td>CL</td>
<td>大部分反潜优秀，属性在重巡和驱逐之间，闪避出色，依旧适合欺负小学生。</td>
</tr>
<tr>
<td>驱逐舰</td>
<td>DD</td>
<td>属性低，消耗低，闪避高，夜战出色，鱼雷战优秀。小学生作为入门舰船，也是必须练的船，一般用来推图带路和完成远征的特定条件。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>炮潜</strong><br>在2015夏季活动中加入的新舰船—絮库夫的舰船种类，虽然会潜水，但是却没有开幕雷击，没多大用处。  </p>
<p><strong>补给舰</strong><br>目前唯一一艘<strong>苏赫巴托尔</strong>，萌萌哒，幸运高，闪避高，技能可以打捞到更好的船，1-5通关奖励。</p>
</blockquote>
<h2 id="驱逐"><a href="#驱逐" class="headerlink" title="驱逐"></a>驱逐</h2><blockquote>
<p>空想、绫波、Z1、萤火虫、Z31、Z16、晓、响、雷、电、敷波和标枪</p>
<p>高星稀有驱逐: 塔什干、奥班农、拉菲等</p>
<p>以及Z系的其他驱逐</p>
</blockquote>
<h2 id="战列"><a href="#战列" class="headerlink" title="战列"></a>战列</h2><table>
<thead>
<tr>
<th>-</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>改造战列</td>
<td>威尔士亲王改、俾斯麦改、罗德尼改、安德烈亚多利亚改、纳尔逊改、内华达改、俄克拉荷马改</td>
</tr>
<tr>
<td>高星稀有</td>
<td>黎塞留、前卫、提尔比茨、华盛顿</td>
</tr>
<tr>
<td>四星</td>
<td>科罗拉多、马里兰，西弗吉尼亚</td>
</tr>
</tbody>
</table>
<h2 id="轻巡"><a href="#轻巡" class="headerlink" title="轻巡"></a>轻巡</h2><table>
<thead>
<tr>
<th>名称</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>海伦娜改</td>
<td>可以给全队增加索敌和命中</td>
</tr>
<tr>
<td>夕张改</td>
<td>觉醒技能后，可以使性能提升很多</td>
</tr>
<tr>
<td>奥希金斯改</td>
<td></td>
</tr>
<tr>
<td>宁海改</td>
<td>经验宝宝，技能可以增加战斗经验</td>
</tr>
<tr>
<td>平海改</td>
<td></td>
</tr>
<tr>
<td>天龙改</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>5星轻巡天狼星，贝尔法斯特<br>4星的基洛夫，以及中国船逸仙、重庆（曙光女神改）</p>
</blockquote>
<h2 id="热门"><a href="#热门" class="headerlink" title="热门"></a>热门</h2><p>埃塞克斯，马汉，M1，睦月，企业号航母，狮，宁海，威奇塔改，拉菲，青叶</p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><table>
<thead>
<tr>
<th>-</th>
<th>第一</th>
<th>第二</th>
<th>产物</th>
</tr>
</thead>
<tbody>
<tr>
<td>战列</td>
<td>400 80 650 130</td>
<td>630 600 650 230</td>
<td>黎塞留、前卫、安德烈亚多利亚、提尔比茨、俾斯麦、华盛顿</td>
</tr>
<tr>
<td>航母轻母</td>
<td>400 600 600 400</td>
<td>500 130 600 400</td>
<td>赤城、加贺、追赶者</td>
</tr>
<tr>
<td>轻巡</td>
<td>200 30 200 100</td>
<td>130 130 130 130</td>
<td>贝尔法斯特、爱丁堡、逸仙、平海、宁海、基洛夫、埃姆登、莱比锡</td>
</tr>
<tr>
<td>驱逐</td>
<td>130 30 130 30</td>
<td>130 130 130 130</td>
<td>拉菲、空想、塔什干（拉菲用3663出货率还是蛮不错的）</td>
</tr>
<tr>
<td>潜艇</td>
<td>30 60 60 30</td>
<td>250 30 250 30</td>
<td>大青花鱼</td>
</tr>
</tbody>
</table>
<h2 id="常用公式产出分析"><a href="#常用公式产出分析" class="headerlink" title="常用公式产出分析"></a>常用公式产出分析</h2><ol>
<li><p>400 80 650 130(前卫公式)<br>当前用的最多的战列公式，出所有战列，所有战巡，所有重巡，4星以上轻巡，重炮以及空想和拉菲这两艘驱逐;屏蔽了航母，轻母，其余轻巡，驱逐以及大青花鱼。</p>
</li>
<li><p>630 600 650 230(黑猫公式)<br>据说是最容易出北宅和猫?出所有战列，所有战巡，所有重巡，重炮以及空想;屏蔽了航母，轻母，所有轻巡，其余驱逐以及大青花鱼。</p>
</li>
<li><p>400 600 600 400(标准航母公式)<br>最早常见的航母公式，出航母，轻母，重巡，4星轻巡以及空想;屏蔽战列，战巡，其余轻巡，其余驱逐，重炮以及大青花鱼。</p>
</li>
<li><p>400 130 500 130(稀有轻巡公式)<br>可以用来赌贝爷(贝尔法斯特)，当然其他4星轻巡也是可以的。出战巡，重巡，稀有轻巡，重炮以及空想;屏蔽战列，航母，轻母，3星以下轻巡，其余驱逐和大青花鱼。</p>
</li>
<li><p>500 130 600 400(航母公式)<br>新型航母公式，相比标准航母公式，屏蔽了轻巡，一定程度上提高了吃喝、追赶的出货率。出航母，轻母，重巡以及空想;屏蔽其余战列，轻巡，重炮，其余驱逐以及大青花鱼。</p>
</li>
<li><p>130 30 130 30(小船通用公式)<br>小船指得是轻巡驱逐潜艇。屏蔽其余舰种船只。如果要鱼的话30 60 60 30就够了。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;
    
    </summary>
    
      <category term="戦艦の女の子" scheme="http://blog.ochukai.me/categories/%E6%88%A6%E8%89%A6%E3%81%AE%E5%A5%B3%E3%81%AE%E5%AD%90/"/>
    
    
      <category term="建造公式" scheme="http://blog.ochukai.me/tags/%E5%BB%BA%E9%80%A0%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中 Timestamp 与 Date 的转化</title>
    <link href="http://blog.ochukai.me/use-js-to-convert-ts-to-data/"/>
    <id>http://blog.ochukai.me/use-js-to-convert-ts-to-data/</id>
    <published>2015-12-02T03:10:44.000Z</published>
    <updated>2016-11-22T01:40:09.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h2><p>今天在处理一个接口时，发现返回的格式是这样的：</p>
<pre><code class="json">{
    &quot;meta&quot;: {
        &quot;has_next_msg&quot;: false
    },
    &quot;objects&quot;: [
        {
            &quot;text&quot;: &quot;111&quot;,
            &quot;from_user_type&quot;: &quot;PAT&quot;,
            &quot;pic&quot;: &quot;&quot;,
            &quot;ts&quot;: 1419939065
        }
    ]
}
</code></pre>
<p><code>ts</code> 那个属性我不太熟悉，不过我觉得应该是 timestamp 的意思吧。后来才知道，<code>ts</code> 就是该条消息的发送时间戳（timestamp），显示这条信息的时候应该显示为日期。</p>
<h2 id="把-Date-转化为-Timestamp"><a href="#把-Date-转化为-Timestamp" class="headerlink" title="把 Date 转化为 Timestamp"></a>把 Date 转化为 Timestamp</h2><p>我们都知道，在 js 里面把 date 转化为 timestamp 的方法比较简单，而且方法也有好多种，比如：</p>
<pre><code class="js">// get the timestamp in seconds
Math.floor(Date.now() / 1000);

// or with a slightly way
Date.now() / 1000 | 0

// Year 2038 problem? lol...
new Date(&#39;Jan 1, 2039&#39;) / 1000 | 0 // -2117514496 

/*----------*/
Math.round(new Date().getTime()/1000);

+new Date / 1000 | 0

~~(Date.now() / 1000)

new Date / 1e3 | 0
</code></pre>
<h2 id="把-Timestamp-转化为-Date"><a href="#把-Timestamp-转化为-Date" class="headerlink" title="把 Timestamp 转化为 Date"></a>把 Timestamp 转化为 Date</h2><p>还有一种需求，比如我要把 timestamp 转化为 <code>1991-10-03 06:01:54</code> ，那么就需要先把这个 timestamp 转化为日期， 然后再进行format吧，正好我找到一个比较方便的办法：</p>
<pre><code class="js">Date.prototype.format = function(format) {
    var o = {
        &#39;M+&#39;: this.getMonth() + 1,          // month
        &#39;d+&#39;: this.getDate(),                 // day
        &#39;h+&#39;: this.getHours(),                  // hour
        &#39;m+&#39;: this.getMinutes(),                  // minute
        &#39;s+&#39;: this.getSeconds(),                    // second     
        &#39;q+&#39;: Math.floor((this.getMonth() + 3) / 3),  // quarter
        &#39;S&#39; : this.getMilliseconds()                 // millisecond
    };

    // year
    if (/(y+)/.test(format) || /(Y+)/.test(format)) {
        format = format.replace(RegExp.$1, (this.getFullYear() + &#39;&#39;)
                       .substr(4 - RegExp.$1.length));
    }

    for (var k in o) {
        if (new RegExp(&#39;(&#39; + k + &#39;)&#39;).test(format)) {
            var first = RegExp.$1;
            var str = first.length === 1
                    ? o[k]
                    : (&#39;00&#39; + o[k]).substr((&#39;&#39; + o[k]).length); // nb
            format = format.replace(first, str);
        }
    }

    return format;
};

function tsToDate(timestamp) {
    return (new Date(timestamp * 1000)).format(&#39;yyyy-MM-dd hh:mm:ss&#39;);
}


// test it
&gt; tsToDate(1448967948)
&lt; &quot;2015-12-01 19:05:48&quot;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题产生&quot;&gt;&lt;a href=&quot;#问题产生&quot; class=&quot;headerlink&quot; title=&quot;问题产生&quot;&gt;&lt;/a&gt;问题产生&lt;/h2&gt;&lt;p&gt;今天在处理一个接口时，发现返回的格式是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;{
    &amp;quo
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.ochukai.me/categories/javascript/"/>
    
    
      <category term="js" scheme="http://blog.ochukai.me/tags/js/"/>
    
      <category term="ts" scheme="http://blog.ochukai.me/tags/ts/"/>
    
      <category term="date" scheme="http://blog.ochukai.me/tags/date/"/>
    
      <category term="format" scheme="http://blog.ochukai.me/tags/format/"/>
    
  </entry>
  
</feed>
