<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="I am Oliver" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>JavaScript 绑定 this - I am Oliver</title><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">I am Oliver</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">カタログ</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2016-12-30T02:28:20.000Z" class="post__time">December 30, 2016</time><h1 class="post__title"><a href="/js-bind-this/">JavaScript 绑定 this</a></h1><div class="post__main echo"><p>其实这篇文章主要是介绍这个东西 <a href="https://github.com/tc39/proposal-bind-operator" target="_blank" rel="external">Proposal Bind Operator</a> 或者 <a href="http://wiki.ecmascript.org/doku.php?id=strawman:bind_operator" target="_blank" rel="external">bind_operator</a>。</p>
<p>也是在一个很偶然的机会看到了，git 上面的一个项目用到了这个用法，为什么自己发现不了这些东西呢？</p>
<h2 id="传统的-this-绑定"><a href="#传统的-this-绑定" class="headerlink" title="传统的 this 绑定"></a>传统的 this 绑定</h2><h3 id="在函数外面暂存一个变量"><a href="#在函数外面暂存一个变量" class="headerlink" title="在函数外面暂存一个变量"></a>在函数外面暂存一个变量</h3><pre><code class="js">// 别名
var self = this;
setTimeout(function() {
  this.doSomething();
}, 1000);
</code></pre>
<h3 id="使用-bind-函数-amp-箭头函数"><a href="#使用-bind-函数-amp-箭头函数" class="headerlink" title="使用 bind 函数 &amp; 箭头函数"></a>使用 bind 函数 &amp; 箭头函数</h3><p>在使用 <code>class *** extends React.Component {}</code> 的写法声明 React 组件的时候，组件的方法都不会被自动绑定 this 了，下面的两种方法比较常见：</p>
<pre><code class="js">// bind
setTimeout(
  function() {
    this.doSomething();
  }.bind(this), 
  1000
);
</code></pre>
<p>使用 <code>bind</code> 方法显得稍微有点长，不太好看，不过很好用。</p>
<pre><code class="js">// var _this = this;

// bind
setTimeout(
  () =&gt; {
    // _this.doSomething();
    this.doSomething();
  }, 
  1000
);
</code></pre>
<p>箭头函数在经过<code>babel</code>编译后， 差不多就是注释的部分了， 还是用的暂存的办法保存了 <code>this</code>，但是写法就简单了太多。</p>
<h3 id=""><a href="#" class="headerlink" title="::"></a>::</h3><p>看到这种语法之后，感觉其他的都弱爆了。</p>
<p>在 React 里面，可以这么写</p>
<pre><code class="jsx">// { title: &#39;******************&#39;, onConfirm: this.handleSave.bind(this) },
&lt;Popconfirm title=&quot;确定要保存吗？&quot; onConfirm={::this.handleSave}&gt;
  &lt;Button type=&quot;ghost&quot; &gt;保存&lt;/Button&gt;
&lt;/Popconfirm&gt;
</code></pre>
<p>可以看到，注释部分表示的编译后的代码，就是用 <code>bind</code> 实现的。</p>
<p>双冒号前面的对象就是 <code>bind</code> 的参数， 如果没有就是当前的 <code>this</code>, 毕竟这种做法就是用来做绑定的。</p>
<p>但是有一个问题，就是像这样的需求不好实现，</p>
<pre><code class="jsx">&lt;Button
  type=&quot;ghost&quot;
  icon=&quot;edit&quot;
  onClick={this.handleEdit.bind(this, item)}
/&gt;
</code></pre>
<p>然后就是黑人问号脸，我试了几种形式 (当然不能用 bind 方法，否则这 :: 没有意义了)</p>
<ul>
<li>[this, item]::this.handleEdit</li>
<li>(this, item)::this.handleEdit  // hhh</li>
<li>this::this.handleEdit(item)    // hhh</li>
</ul>
<p>感觉唯一靠谱的就是第一种写法了， 编译之后</p>
<pre><code class="js">_react2.default.createElement(
  _button2.default,
  { 
    type: &#39;ghost&#39;, 
    icon: &#39;edit&#39;, 
    onClick: (_context = [this, item], this.handleEdit).bind(_context) 
  },
  &#39;&#39;
)
</code></pre>
<p>这样 bind 之后的方法内的 this 是一个数组，要想获取到真正的 this, 在 handleEdit 中还需要做</p>
<pre><code class="js">function handleEdit () {
  // this: [this, item]
  // 感觉好尴尬~
  console.log(this[0]);
  // const [ _this, item ] = this;
}
</code></pre>
<blockquote>
<p>所以呢 在需要绑定 this 并且要添加额外参数的时候，就不要用 <strong>::</strong> 了。老老实实用 <strong>bind</strong> 就好了。</p>
</blockquote>
<h2 id="箭头函数声明在-class-里面"><a href="#箭头函数声明在-class-里面" class="headerlink" title="箭头函数声明在 class 里面"></a>箭头函数声明在 class 里面</h2><pre><code class="jsx">class Example extends React.Component {

  handleButtonClick = (e) =&gt; {
    this.setState({ loading: true });
  };

  render() {
    return &lt;Button onClick={this.handleButtonClick}&gt;;
  }

}

// var Example = React.createClass({
//
//   handleButtonClick: function(e) {
//     this.setState({ loading: true });
//   },
//   ...
// });
</code></pre>
<p>这样应该是最简单的方式了，因为是自动绑定 this 的（与注释中的代码效果是一样的）。</p>
<p>以上。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/this/" class="post__tag__link">this</a></li><li class="post__tag__item"><a href="/tags/js/" class="post__tag__link">js</a></li></ul></footer></article><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript></div></div></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2017 Oliver Wang</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><a title="Next" href="/correct-ugly-markdown-css-in-webstorm/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})(document,"script","ochukai","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-73840162-1');
ga('send','pageview');
</script><script src="http://code.jquery.com/jquery-3.1.1.min.js"></script><script src="/js/main.js"></script></body></html>